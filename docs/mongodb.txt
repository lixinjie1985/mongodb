MongoDB是一个开源文档数据库，提供高性能，高可用，自动扩展。高性能，支持索引查询，索引可以建在内嵌文档的key上。
丰富的查询语言。高可用，副本集合，自动故障转移，数据冗余存储。水平扩展，通过分片实现水平扩展。支持多种存储引擎

文档，在编程语言中有与之对应的数据类型，嵌套（嵌入）的文档和数组减少了表连接，动态方案支持流式多态

高性能，嵌套文档减少IO活动，索引支持快速查询，高可用，MongoDB的复制功能，提供自动故障转移和数据冗余。一个副本集合是一组MongoDB服务器，
维护相同的数据集，提供冗余和提高数据可用性。水平扩展性是其核心功能，分片（sharding）可以在一个集群内分发数据，从3.4支持基于shard key创建数据zones

数据库，集合，文档，从3.4可以从集合或其它视图创建只读视图，视图使用底层集合的索引，不能指定$natural排序，视图也被认为是分区的如果底层集合是分区的，
视图创建时可以指定一个默认排序规则，如果不指定将使用simple的二进制比较，视图不继承集合的排序规则。视图里字符串的比较使用视图的默认排序规则，
改变或重写视图的默认排序规则将报错。如果从另一个视图创建视图时，不能指定和源视图不同的排序规则。如果多个视图进行聚合，它们必须具有相同的排序规则

有上限的集合，固定大小的集合支持高吞吐量操作，插入和按插入的顺序获取，工作方式与循环缓冲区相似，一旦填满之后就开始覆盖最旧的数据。可以保持插入顺序，
支持很高的插入吞吐量。记录日志的速度与直接把日志写入文件系统的速度相近，默认就是先进先出的顺序，与事件发生顺序一致。具有_id字段且该字段上有索引。
限制和建议，要更新的话请建立索引，避免全集合扫描。如果一个更新或替换操作改变了集合里的文档的大小，操作将失败。无法删除集合里的文档，
如果要清空集合的话可以把该集合删除再建一个集合。上限集合不能分片。以自然顺序获取最近插入元素很有效，类似日志文件的尾部。创建集合时要指定占用空间的大小，
也可以指定最多存储的文档个数。可以使用尾部游标（类似tail -f），来获取刚插入的数据

文档，BSON是JSON的二进制表示，但包含更多的数据类型。_id被保留用作主键，它的值必须集合内唯一且不可变，可以是除数组外的其它任何数据类型。
字段名称不能包含美元符号，点符号和null。使用点来访问数组元素和嵌入文档的字段，基于0的索引访问数组<array>.<index>，访问嵌入文档<embedded document>.<field>。
文档最大不能超过16M，超过后需要使用GridFS进行存储。文档字段的顺序会按写入顺序被保持，当重命名字段名称时会发生重排序但也尽力保持，但_id字段总是第一个。
集合中的每个文档都要求有一个唯一的_id字段作为主键，如果插入时没有指定，则驱动会自动生成一个ObjectId类型的_id字段。

BSON类型，BSON是一种二进制序列化格式用于存储文档和mongo中的远程过程调用。支持多种数据类型，每种类型都有一个数字编号和字符串形式的别名，
可用于$type操作符按数据类型进行文档查询。ObjectId特点，小，可能唯一，快速生成，有序。共12个字节，4个字节的时间戳，3个字节的机器标识，2个字节的进程ID，
3个字节的计数器，从某个随机数开始。使用该数据类型可以获得创建时间，按该类型字段排序大约等于按创建时间排序。Date类型8字节和java中的一样，表示毫秒数。
Timestamp类型8字节，前4个字节表示时间的秒数，后4个字节表示在这一秒内按操作顺序逐渐增加的一个数字

https://docs.mongodb.com/manual/crud/
Create Operations
往集合中插入文档时，如果集合不存在则创建集合。insertOne()插入一个，insertMany()插入多个，insert()插入一个或多个，插入操作的目标是单个集合。对单个文档的所有写操作都是原子的
save()和bulkWrite()也可以用于插入。所有更新和替换操作当设置upsert:true时也可以用于插入
Read Operations
使用find()方法从集合中查询文档，可以指定查询过滤器或查询条件。可以使用com.mongodb.client.model.Filters类里的静态方法指定查询条件。包括and，or，in，like，正则
等于等类似和SQL一样的操作符。或者使用带美元符号的操作符，如$and，$or，$in等
匹配一个嵌入的文档可以让一个字段的值等于一个文档。匹配一个嵌套的字段，可以使用点号进行导航
要完全匹配一个数组，可以使用eq操作符指定一个数组，元素的值和顺序保持一致。要匹配一个数组包含某些元素，可以使用all操作符指定一个数组，只要包含了指定的所有元素的数组都算匹配
要匹配一个数组包含某一个元素，可以使用eq操作符指定单个元素值，也可以使用其它操作符做单个元素值的比较。可以使用点号加索引的方式匹配数组某个位置的元素，索引从0开始
使用size操作符进行数组长度的匹配
如果一个数组的元素也是一个文档，进行相等匹配时字段的顺序和值都必须一致。可以用点号指定索引再指定属性，表示指定位置元素的指定属性。如果不指定索引直接指定属性，表示所有元素的这个属性进行匹配，且至少有一个元素的属性满足
使用projection进行投影，include表示包含在返回字段中，exclude表示从返回字段中排除，如果是嵌套文档字段的话，可以使用点号导航。slice可以用来指定返回数组的哪个元素
使用eq操作符指定一个字段的值为null时，表示要么该字段值为null，要么不包含该字段。type指定字段值为null，表示该字段存在，但值是null。exists指定字段值为true或false，表示该字段存在或不存在

Update Operations
更新集合中已存在的文档，updateOne()最多更新一个，updateMany()更新多个，replaceOne()替换一个，update()可以替换一个，更新一个或更新多个，默认更新一个。更新操作的目标是单个集合，
对单个文档的所有写操作都是原子的。可以指定条件或过滤器来选出被更新的文档，指定的方法和查询时的一样
使用set设置单个字段名称和值，使用combine把多个set联合起来，使用currentDate表示当前时间。在更新时不能更新_id字段，即使在文档替换时，_id字段的值也要保持不变，所以
新文档最好不要包含_id字段。更新时如果文档的大小增加了且超出了为原来文档分配的大小，更新操作会使文档在磁盘上被重新定位
文档字段的顺序按写入时保持，但_id字段总是位于第一个，更新时如果涉及字段重命名的话，将导致所有字段重排序，但是也会积极地保持字段的原有顺序
在更新或替换时，如果设置了upsert为true，当没有文档匹配时会插入一个新的文档

Delete Operations
删除操作从集合中移除文档，deleteOne()最多删除一个，deleteMany()删除多个，remove()删除一个或删除多个，删除操作的目标是单个集合，对单个文档的所有写操作都是原子的
可以指定条件或过滤器来选出被删除的文档，指定的方法和查询时的一样。findOneAndDelete()可以指定一个排序规则，删除排序后的第一个
删除操作不会删除索引，即使删除集合里的所有文档

批量写操作，只能针对单个集合，允许应用定义可接受的必要确认级别。如果设置为有序，则顺序地执行，遇到错误就返回，不再执行后面的。如果设置为无序，则并行执行，
其中一个出错，不影响其它的执行。插入、更新、替换和删除操作可以在一个批量写中执行。
批量操作接收一个数组，数组中的每个元素都是一个文档，文档只包含一个字段，该字段的名称表明操作类型，该字段的值也是一个文档。支持的字段名称有，insertOne、updateOne
updateMany、replaceOne、deleteOne、deleteMany。每种操作都有自己的书写格式
分片集合批量插入策略，预分割集合，如果分片集合是空的，那么它只有一个初始化块，位于一个单一分片上。为了避免性能耗费，可以预分割集合。
无序写入，尝试同时把写请求发送到多个分片。避免单调的分片key，如果你的分片key在插入时是单调增长，这样将导致所有的插入都集中在最后一个块上，无法发挥集群优势
如果非用单调分片key的话，可以采用把key的二进制bit位反序，或者交换某部分二进制bit位，来使插入操作分散到多个块上，避免单点过热

SQL到MongoDB的映射图。https://docs.mongodb.com/manual/reference/sql-comparison/

读关注，副本集合和副本集合分片的读关注查询选项决定从一个查询中返回哪些些数据。读关注级别，

写关注，

原子性和事务，在单个文档级别的写操作是原子的，即使修改了多个嵌套（嵌入）文档。一个写操作修改多个文档时，对单个的修改是原子的，所有的修改不是原子的。

读隔离、一致性和新近性，

分布式查询，对分片集群的读操作，





分片，是一个在多个机器间分发数据的方法，mongodb使用分片来支持超大数据集的部署和高吞吐量操作。纵向扩展和横向扩展，纵向扩展主要考虑增强单机性能，这往往受到科技的限制。横向扩展是把大的系统分割并运行在多个机器上，扩展时只需增加额外的机器。mongodb分片集群由三种组件组成，shard，包含所有分片数据的一个子集，部署为一个主从集群。mongos，路由器，提供应用和分片集群间的接口。config servers，存储元数据和配置信息，部署为主从集群。所有分片数据是在集合级别，在集群中各个分片间分发集合数据。分片key，用来分割一个集合中的文档，由集合中每个文档里都出现的一个或多个不可变字段组成。当分片集合时需要选择分片key，一旦选择不能再更改，只能有一个分片key。分片key必须有索引。分片key的选择会影响分片集群。块，mongodb把分片数据分割成块，每个块基于分片key有一个包含下边界和不包含上边界的范围。使用均衡器在分片集群的各个分片间迁移块。在分片集群的各个分片间分发读写操作。包含分片key或复合分片key前缀的查询会被定位到一个指定的分片上或一组分片上，其它的查询以广播的形式分发到各个分片，可能执行时间较长。高可用，一到多个分片不可用时，整个集群还可以提供部分读写操作，不可用的分片无法访问，可用的分片可以继续访问。在生产环境，单个分片应该部署成主从节点式的，增加冗余和可用性。分片集合和非分片集合，它们可以共存，分片集合的数据分割到集群中的各个分片上，非分片集合的数据存储在一个主要分片上，每个数据库有自己的主要分片。连接到分片集群，必须连接到一个mongos路由器上，再与集群中的任何集合交互，包括分片和非分片集合。客户端永远不能连到单个分片上。支持两种分片策略在集群中分发数据。哈希分片，计算分片key字段值的哈希，每个块（chunk）基于哈希值被分配一个区间。基于范围的查询将很难定位到单个分片上，导致更多的广播操作。范围分片，基于分片key的值把数据划分成范围，每一块（chunk）基于分片key的值分配一个区间。在集群中可以基于分片key创建zone，一个zone可以关联一到多个shard，一个shard可以关联任意数目的非冲突zone。在平衡的集群中，chunk的迁移只能在关联到同一个zone的shard间进行


